<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="OOP (Object-Oriented Programming)" />
<meta property="og:description" content="객체 지향 프로그래밍이란?  컴퓨터 프로그래밍의 패러다임 중 하나 프로그램을 명령어의 목록으로 보는 시각에서 벗어나, 여러 개의 독립된 단위(객체)로 파악하고자 하는 것 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됨 보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있음
  구성요소  클래스 (Class)  사용자 정의 데이터형 (User defined data type) 같은 종류(또는 문제 해결을 위한)의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것  객체 (Object)  클래스의 인스턴스(실제로 메모리에 할당된 것) 자신 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있음 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써, 메모리를 경제적으로 사용함  메서드 (Method)  클래스로부터 생성된 객체를 사용하는 방법, 객체에 명령을 내리는 메시지 한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는데 사용됨   특징 캡슐화 (Encapsulation)  필요한 속성(attribute)와 행위(methods)를 하나로 묶음 일부를 외부에서 사용하지 못하도록 은닉함  정보은닉 (Information Hiding)  프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것 내부 구현은 감춰서 모듈 내에서의 응집도를 높이고, 외부 노출을 최소화하여 모듈 간의 결합도를 떨어뜨려 유연함과 유지보수성을 높임 접근 제한자 종류  public : 클래스 외부에서 사용 가능 protected : 다른 클래스에는 노출되지 않지만, 상속받은 자식 클래스에는 노출됨 private : 클래스 내부에서만 사용되며 외부로 노출되지 않음     Example ↕  public class Student { private String name; public void setName(String name) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/oop/" />
<meta property="article:published_time" content="2019-10-19T11:04:58+09:00" />
<meta property="article:modified_time" content="2019-10-23T08:38:24+09:00" />
<title>OOP (Object-Oriented Programming) | 끄적끄적..</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.1b994bd28c6ce2255f069b6bf6837b4d396307637fc48d61dcb2a6caac26e031.css" integrity="sha256-G5lL0oxs4iVfBptr9oN7TTljB2N/xI1h3LKmyqwm4DE=">


<script defer src="/search.min.40ecf94fc831a1e0ec5311a5201e795beadaa1019b084e031b85f4accf5c5b34.js" integrity="sha256-QOz5T8gxoeDsUxGlIB55W&#43;raoQGbCE4DG4X0rM9cWzQ="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="/"><span>끄적끄적..</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/docs/cloud/"><strong>Cloud Computing</strong></a>

<ul>
<li><a href="/docs/cloud/IaaS/">IaaS</a></li>
<li><a href="/docs/cloud/PaaS/">PaaS</a></li>
<li><a href="/docs/cloud/SaaS/">SaaS</a></li>
</ul></li>
<li><a href="/docs/java/"><strong>Java</strong></a></li>
<li><a href="/docs/example/"><strong>Example Site</strong></a></li>
<li><a href="/docs/example/table-of-contents/">Table of Contents</a>

<ul>
<li><a href="/docs/example/table-of-contents/with-toc/">With ToC</a></li>
<li><a href="/docs/example/table-of-contents/without-toc/">Without ToC</a><br /></li>
</ul></li>
<li><strong>Shortcodes</strong></li>
<li><a href="/docs/shortcodes/buttons/">Buttons</a></li>
<li><a href="/docs/shortcodes/expand/">Expand</a></li>
<li><a href="/docs/shortcodes/hints/">Hints</a></li>
<li><a href="/docs/shortcodes/katex/">Katex</a></li>
<li><a href="/docs/shortcodes/mermaid/">Mermaid</a></li>
<li><a href="/docs/shortcodes/tabs/">Tabs</a><br /></li>
<li><a href="/posts/"><strong>Blog</strong></a></li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-posts">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>OOP (Object-Oriented Programming)</strong>
</header>

      

<header class="markdown">
  <h1>OOP (Object-Oriented Programming)</h1>
  <h5>
    <strong>Oct 19, 2019</strong>
  </h5>
</header>
<article class="markdown">

<h2 id="객체-지향-프로그래밍이란">객체 지향 프로그래밍이란?</h2>

<ul>
<li>컴퓨터 프로그래밍의 패러다임 중 하나</li>
<li>프로그램을 명령어의 목록으로 보는 시각에서 벗어나, 여러 개의 독립된 단위(객체)로 파악하고자 하는 것</li>
<li>각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음</li>
<li>프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됨</li>
<li>보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있음<br /></li>
</ul>

<h2 id="구성요소">구성요소</h2>

<ul>
<li>클래스 (Class)

<ul>
<li>사용자 정의 데이터형 (User defined data type)</li>
<li>같은 종류(또는 문제 해결을 위한)의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것</li>
</ul></li>
<li>객체 (Object)

<ul>
<li>클래스의 인스턴스(실제로 메모리에 할당된 것)</li>
<li>자신 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있음</li>
<li>객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써, 메모리를 경제적으로 사용함</li>
</ul></li>
<li>메서드 (Method)

<ul>
<li>클래스로부터 생성된 객체를 사용하는 방법, 객체에 명령을 내리는 메시지</li>
<li>한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는데 사용됨</li>
</ul></li>
</ul>

<h2 id="특징">특징</h2>

<h3 id="캡슐화-encapsulation">캡슐화 (Encapsulation)</h3>

<ul>
<li>필요한 속성(attribute)와 행위(methods)를 하나로 묶음</li>
<li>일부를 외부에서 사용하지 못하도록 은닉함</li>
</ul>

<h4 id="정보은닉-information-hiding">정보은닉 (Information Hiding)</h4>

<ul>
<li>프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것</li>
<li>내부 구현은 감춰서 모듈 내에서의 응집도를 높이고, 외부 노출을 최소화하여 모듈 간의 결합도를 떨어뜨려 유연함과 유지보수성을 높임</li>
<li>접근 제한자 종류

<ul>
<li>public : 클래스 외부에서 사용 가능</li>
<li>protected : 다른 클래스에는 노출되지 않지만, 상속받은 자식 클래스에는 노출됨</li>
<li>private : 클래스 내부에서만 사용되며 외부로 노출되지 않음
<br /></li>
</ul></li>
</ul>

<div class="book-expand">
  <label>
    <div class="book-expand-head flex justify-between">
      <span>Example</span>
      <span>↕</span>
    </div>
    <input type="checkbox" class="hidden" />
    <div class="book-expand-content markdown-inner">
      <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">class</span> Student {
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">String</span> name;

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> setName(String <span style="color:#a6e22e">name</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> getName() {
        <span style="color:#66d9ef">return</span> name;
    }
}</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">class</span> School {
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String[] <span style="color:#a6e22e">ar</span>) {
        Student <span style="color:#a6e22e">student</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Student();
        student.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;홍길동&#34;</span>);
        
        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Name: &#34;</span> <span style="color:#f92672">+</span> student.<span style="color:#a6e22e">getName</span>());
    }
}</code></pre></div>
<pre><code>- 변수(name)는 private 접근제어자로 현재 클래스에서만 호출할 수 있도록 함 
- 필요한 기능만 public 접근제어자로 다른 클래스에서 접근할 수 있도록 함  
</code></pre>

    </div>
  </label>
</div>


<h3 id="상속-inheritance">상속 (Inheritance)</h3>

<ul>
<li>자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것</li>
<li>IS-A 관계를 가짐</li>
</ul>

<h3 id="다형성-polymorphism">다형성 (Polymorphism)</h3>

<ul>
<li>하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것</li>

<li><p>서브타입 다형성 (Subtype Polymorphism / Subtyping)</p>

<h4 id="기초-클래스-또는-인터페이스를-구현하는-상위-클래스를-생성하고-해당-클래스를-상속받는-다수의-하위-클래스를-만들어-상위-클래스의-포인터나-참조변수-등이-하위-클래스의-객체를-참조하게-하는-것">기초 클래스 또는 인터페이스를 구현하는 상위 클래스를 생성하고, 해당 클래스를 상속받는 다수의 하위 클래스를 만들어 상위 클래스의 포인터나 참조변수 등이 하위 클래스의 객체를 참조하게 하는 것</h4>

<h4 id="각-하위-클래스는-상위-클래스의-메서드-위에-자신의-메서드를-덮어쓰는-메서드-오버라이딩을-수행하며-상위-클래스의-참조변수가-어떤-하위-클래스의-객체를-참조하느냐에-따라-호출되는-메서드가-달라짐">각 하위 클래스는 상위 클래스의 메서드 위에 자신의 메서드를 덮어쓰는 메서드 오버라이딩을 수행하며, 상위 클래스의 참조변수가 어떤 하위 클래스의 객체를 참조하느냐에 따라 호출되는 메서드가 달라짐</h4></li>

<li><p>매개변수 다형성 (Parametric Polymorphism)</p>

<h4 id="타입을-매개변수로-받아서-새로운-타입을-되돌려주는-기능-컴파일-시-지정한-타입에-따라-해석됨">타입을 매개변수로 받아서 새로운 타입을 되돌려주는 기능 (컴파일 시 지정한 타입에 따라 해석됨)</h4>

<ul>
<li><p>템플릿 (Template)</p>

<h5 id="타입-매개변수를-입력한-타입으로-치환한-코드를-생성하는-방식-c">- 타입 매개변수를 입력한 타입으로 치환한 코드를 생성하는 방식 (C++)</h5></li>

<li><p>제네릭 (Generic)</p>

<h5 id="지정한-타입-매개변수에-해당하는-타입만-사용하는-방식-java-c">지정한 타입 매개변수에 해당하는 타입만 사용하는 방식 (Java, C#)</h5></li>
</ul></li>

<li><p>임시 다형성 (Ad hoc Polymorphism)</p>

<ul>
<li><p>함수 오버로딩 (Function overloading)</p>

<h5 id="동일한-이름의-함수를-매개변수에-따라-다른-기능으로-동작하도록-할-수-있음-c-c-java">동일한 이름의 함수를 매개변수에 따라 다른 기능으로 동작하도록 할 수 있음 (C++, C#, Java)</h5></li>

<li><p>연산자 오버로딩 (Operator overloading)</p>

<h5 id="연산자를-오버로딩하여-기본-연산자가-해당-클래스에-맞는-역할을-수행하게-하는-것-c-c">연산자를 오버로딩하여 기본 연산자가 해당 클래스에 맞는 역할을 수행하게 하는 것 (C++, C#)</h5></li>
</ul></li>

<li><p>강제 다형성 (Coercion Polymorphism)</p>

<ul>
<li><p>묵시적 형변환 (Implicit type coercion)</p>

<h5 id="ex-double-a-30">ex. double a = 30;</h5></li>

<li><p>명시적 형변환 (Explicit type coercion)</p>

<h5 id="ex-double-a-double-30">ex. double a = (double) 30;</h5></li>
</ul></li>
</ul>

<h2 id="5대-원칙">5대 원칙</h2>

<h3 id="단일-책임-원칙-single-responsibility-principle-srp">단일 책임 원칙 (Single Responsibility Principle, SRP)</h3>

<ul>
<li>객체는 오직 하나의 책임을 가져야 함</li>
<li>객체는 오직 하나의 변경 이슈만을 가져야 함</li>
</ul>

<h3 id="개방-폐쇄-원칙-open-close-principle-ocp">개방-폐쇄 원칙 (Open-Close Principle, OCP)</h3>

<ul>
<li>객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 함</li>
<li>객체 기능의 확장을 허용하고 스스로의 변경은 피해야 함</li>
</ul>

<h3 id="리스코프-치환-원칙-liskov-substitution-principle-lsp">리스코프 치환 원칙 (Liskov Substitution Principle, LSP)</h3>

<ul>
<li>자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 함</li>
</ul>

<h3 id="인터페이스-분리-원칙-interface-segregation-principle-isp">인터페이스 분리 원칙 (Interface Segregation Principle, ISP)</h3>

<ul>
<li>클라이언트에서 사용하지 않는 메서드는 사용하면 안됨</li>
</ul>

<h3 id="의존성-역전-원칙-dependency-inversion-principle-dip">의존성 역전 원칙 (Dependency Inversion Principle, DIP)</h3>

<ul>
<li>추상성이 높고 안정적인 클래스는 구체적이고 불안정한 저수준의 클래스에 의존하면 안됨</li>
<li>객체지향의 인터페이스를 통해 해당 원칙을 준수할 수 있음

<ul>
<li>추상화한 인터페이스를 구현한 클래스는 클라이언트 변경없이 교체 가능해야 함</li>
</ul></li>
</ul>

<h2 id="참고자료">참고자료</h2>

<ul>
<li>나무위키

<ul>
<li><a href="https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">객체 지향 프로그래밍</a></li>
<li><a href="https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99">객체 지향 프로그래밍 - 원칙</a></li>
</ul></li>
</ul>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a class="flex align-center" href="https://github.com/pirate-docs/pirate-posts/commit/0c2eff51faea5a1d14b2a760d58326fea8bad97e" title='Last modified Oct 23, 2019 by andrew' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" />
      <span>Oct 23, 2019</span>
    </a>
  </div>
  
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#객체-지향-프로그래밍이란">객체 지향 프로그래밍이란?</a></li>
<li><a href="#구성요소">구성요소</a></li>
<li><a href="#특징">특징</a>
<ul>
<li><a href="#캡슐화-encapsulation">캡슐화 (Encapsulation)</a>
<ul>
<li><a href="#정보은닉-information-hiding">정보은닉 (Information Hiding)</a></li>
</ul></li>
<li><a href="#상속-inheritance">상속 (Inheritance)</a></li>
<li><a href="#다형성-polymorphism">다형성 (Polymorphism)</a>
<ul>
<li><a href="#기초-클래스-또는-인터페이스를-구현하는-상위-클래스를-생성하고-해당-클래스를-상속받는-다수의-하위-클래스를-만들어-상위-클래스의-포인터나-참조변수-등이-하위-클래스의-객체를-참조하게-하는-것">기초 클래스 또는 인터페이스를 구현하는 상위 클래스를 생성하고, 해당 클래스를 상속받는 다수의 하위 클래스를 만들어 상위 클래스의 포인터나 참조변수 등이 하위 클래스의 객체를 참조하게 하는 것</a></li>
<li><a href="#각-하위-클래스는-상위-클래스의-메서드-위에-자신의-메서드를-덮어쓰는-메서드-오버라이딩을-수행하며-상위-클래스의-참조변수가-어떤-하위-클래스의-객체를-참조하느냐에-따라-호출되는-메서드가-달라짐">각 하위 클래스는 상위 클래스의 메서드 위에 자신의 메서드를 덮어쓰는 메서드 오버라이딩을 수행하며, 상위 클래스의 참조변수가 어떤 하위 클래스의 객체를 참조하느냐에 따라 호출되는 메서드가 달라짐</a></li>
<li><a href="#타입을-매개변수로-받아서-새로운-타입을-되돌려주는-기능-컴파일-시-지정한-타입에-따라-해석됨">타입을 매개변수로 받아서 새로운 타입을 되돌려주는 기능 (컴파일 시 지정한 타입에 따라 해석됨)</a>
<ul>
<li><a href="#타입-매개변수를-입력한-타입으로-치환한-코드를-생성하는-방식-c">- 타입 매개변수를 입력한 타입으로 치환한 코드를 생성하는 방식 (C++)</a></li>
<li><a href="#지정한-타입-매개변수에-해당하는-타입만-사용하는-방식-java-c">지정한 타입 매개변수에 해당하는 타입만 사용하는 방식 (Java, C#)</a></li>
<li><a href="#동일한-이름의-함수를-매개변수에-따라-다른-기능으로-동작하도록-할-수-있음-c-c-java">동일한 이름의 함수를 매개변수에 따라 다른 기능으로 동작하도록 할 수 있음 (C++, C#, Java)</a></li>
<li><a href="#연산자를-오버로딩하여-기본-연산자가-해당-클래스에-맞는-역할을-수행하게-하는-것-c-c">연산자를 오버로딩하여 기본 연산자가 해당 클래스에 맞는 역할을 수행하게 하는 것 (C++, C#)</a></li>
<li><a href="#ex-double-a-30">ex. double a = 30;</a></li>
<li><a href="#ex-double-a-double-30">ex. double a = (double) 30;</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#5대-원칙">5대 원칙</a>
<ul>
<li><a href="#단일-책임-원칙-single-responsibility-principle-srp">단일 책임 원칙 (Single Responsibility Principle, SRP)</a></li>
<li><a href="#개방-폐쇄-원칙-open-close-principle-ocp">개방-폐쇄 원칙 (Open-Close Principle, OCP)</a></li>
<li><a href="#리스코프-치환-원칙-liskov-substitution-principle-lsp">리스코프 치환 원칙 (Liskov Substitution Principle, LSP)</a></li>
<li><a href="#인터페이스-분리-원칙-interface-segregation-principle-isp">인터페이스 분리 원칙 (Interface Segregation Principle, ISP)</a></li>
<li><a href="#의존성-역전-원칙-dependency-inversion-principle-dip">의존성 역전 원칙 (Dependency Inversion Principle, DIP)</a></li>
</ul></li>
<li><a href="#참고자료">참고자료</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
